#pragma config(Sensor, in1,    p1,                  sensorPotentiometer)
#pragma config(Sensor, in2,    p2,                  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  QuadCenter,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  QuadLeft,            sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  QuadRight,           sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  DonutSonar,          sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  j1,                  sensorTouch)
#pragma config(Sensor, dgtl10, j2,                  sensorTouch)
#pragma config(Sensor, dgtl11, j3,                  sensorTouch)
#pragma config(Sensor, dgtl12, j4,                  sensorTouch)
#pragma config(Motor,  port1,           DriveCenter,   tmotorNormal, openLoop)
#pragma config(Motor,  port2,           DriveLeftFront, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port3,           DriveLeftRear, tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port4,           DriveRightFront, tmotorNormal, openLoop)
#pragma config(Motor,  port5,           DriveRightRear, tmotorNormal, openLoop)
#pragma config(Motor,  port6,           Arm1,          tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port7,           Spinner,       tmotorNormal, openLoop)
#pragma config(Motor,  port8,           Arm3,          tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port9,           Arm4,          tmotorNormal, openLoop)
#pragma config(Motor,  port10,          Arm2,          tmotorNormal, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

int QLeft;
int QRight;
int QCenter;

#include "Vex_Competition_Includes.c"
#include "Functions.c"
//#include "Alpha.c"
//#include "Beta.c"
//#include "Gamma.c"
#include "Delta.c"

void pre_auton()
{
    QLeft = 0;
    QRight = 0;
    QCenter = 0;

    SensorValue[QuadCenter] = 0;
    SensorValue[QuadLeft] = 0;
    SensorValue[QuadRight] = 0;
}

task autonomous()
{
    // Delta for reference

    // Initial test.
    // Make sure you do this on mats.
    // Probably gonna need to do it again at competition.
    // The robot should move forward. Record the sensor values in the debugging window.
    // Set the constant to the SensorValue - 85.
    // Try to keep the constants the same.
    // Repeat until you get 5 consecutive runs within a range of 10 (+/- 5).
    // If you cannot get a range of 10 while keeping the constants the same,
    // the left and right values may have to be done seperately.

    // After Forward constants have been set, proceed to work on Backward, then TurnLeft, then TurnRight.
    // Backward(-85, -85);
    // TurnLeft(-85, 85);
    // TurnRight(85, -85);
    // The turning fuctions are less accurate.
    // If time allows, proceed to do Left and Right.
    // Left(300);
    // or
    // Right(300);

    if(SensorValue[j1]) // blue
    {
        if(SensorValue[j2]) //normal
        {
            //Gamma();
        }
        else // oppo
        {
            //Alpha();
        }
    }
    else // red
    {
        if(SensorValue[j2]) // normal
        {
            //Beta();
        }
        else // oppo
        {
            Delta();
        }
    }
}

int count;
task usercontrol()
{
    if(vexRT[Btn5D] && vexRT[Btn5U] && vexRT[Btn6D] && vexRT[Btn6U])
    {
        StartTask(autonomous);
        wait1Msec(20000);
        StopTask(autonomous);
    }

    float multiplier = 1;
    bool wall = false;
    bool base = false;
    bool down = false;
    bool macro = false;
    int id = 0;

    while (true)
    {
        count = GetDonutCount();
        Drive(multiplier);

        if(vexRT[Btn7U])
        {
            wall = true;
            base = false;
            down = false;
            macro = false;
        }
        else if(vexRT[Btn7D])
        {
            wall = false;
            base = true;
            down = false;
            macro = false;
        }
        else if(vexRT[Btn7L])
        {
            wall = false;
            base = false;
            down = true;
            macro = false;
        }

        if(vexRT[Ch2] > 20 || vexRT[Ch2] < -20)
        {
            Arm();
            wall = false;
            base = false;
            down = false;
            macro = false;
        }
        else if(wall)
        {
            if(SensorValue[p1] + SensorValue[p2] != 2891) //2502 -> 2891
            {
                Arm(520 - (SensorValue[p1] + SensorValue[p2]) / 6);
            }
            else
            {
                wall = false;
            }
        }
        else if(base)
        {
            if(SensorValue[p1] + SensorValue[p2] != 2212) //2060 -> 2212
            {
                Arm(271 - (SensorValue[p1] + SensorValue[p2]) / 10);
            }
            else
            {
                base = false;
            }
        }
        else if(down)
        {
            if(SensorValue[p1] + SensorValue[p2] > 12)
            {
                Arm(-127);
            }
            else
            {
                down = false;
            }
        }
        else if(!macro)
        {
            Trim();
        }

        if(vexRT[Btn5U])
        {
            macro = false;
            Down();
        }
        else if(!macro)
        {
            Up();
        }

        if(vexRT[Btn8D])
        {
            multiplier = 0.25;
        }
        else if(vexRT[Btn8L])
        {
            multiplier = 0.5;
        }
        else if(vexRT[Btn8U])
        {
            multiplier = 0.75;
        }
        else if(vexRT[Btn8R])
        {
            multiplier = 1;
        }

        if(macro)
        {
            // macro id's
            // 1 = pick up 4
            switch (id)
            {
            case 1:
                if(SensorValue[p1] + SensorValue[p2] > 400)
                {
                    Arm(-127);
                }
                else
                {
                    Trim();

                    if(SensorValue[QuadLeft] < 35)
                    {
                        DriveLeft(30);
                    }
                    else
                    {
                        LeftBrake();
                    }

                    if(SensorValue[QuadRight] < 35)
                    {
                        DriveRight(30);
                    }
                    else
                    {
                        RightBrake();
                    }

                    Arm(-127);
                    // Modify this value (40) if it isn't picking up enough,
                    // if that still doesn't work, consider moving the Trim() function to after the last while loop.
                    if(SensorValue[p1] + SensorValue[p2] > 40)
                    {
                        Arm(-127);
                    }
                    else
                    {
                        if(SensorValue[p1] + SensorValue[p2] < 2212) //2060 -> 2212
                        {
                            Arm(271 - (SensorValue[p1] + SensorValue[p2]) / 10);
                        }
                        else
                        {
                            Trim();
                        macro = false;
                        id = 0;
                        }
                    }
                }
                break;
            case 2:
                if(GetDonutCount() > 0)
                {
                    Down();
                }
                else
                {
                    Up();
                    macro = false;
                    id = 0;
                }
                break;
            }
        }

        if(vexRT[Btn6U])
        {
            wall = false;
            base = false;
            down = false;
            macro = true;

            SensorValue[QuadCenter] = 0;
            SensorValue[QuadLeft] = 0;
            SensorValue[QuadRight] = 0;

            if(GetDonutCount() < 3 && SensorValue[p1] + SensorValue[p2] > 1500 && SensorValue[p1] + SensorValue[p2] < 2212)
            {
                id = 1;
            }
            else if(GetDonutCount() > 0 && SensorValue[p1] + SensorValue[p2] >= 2212)
            {
                // NOTE: No point of this.............
                id = 2;
            }
        }
    }
}
